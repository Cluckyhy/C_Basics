//#include <stdio.h>
//#include <Windows.h>
//
////%d -- 打印的是十进制有符号数字
////%u -- 打印的是十进制无符号数字
//
//
//int main() {
//
//	char a = -1;
//	//10000000 00000000 00000000 00000001	--原码
//	//11111111 11111111 11111111 11111110	--反码
//	//11111111 11111111 11111111 11111111	--补码
//	//因为是char类型，所以进行截取-->11111111
//	//因为要输出的是以十进制输出的有符号数，需要进行整型提升：
//	//因为char类型是有符号位的，看11111111第一位是1，认为是负数，
//	//所以在前面补1得
//	//11111111111111111111111111111111111	--得到补码
//	//再计算出原码就是-1;
//	signed char b = -1;
//	//10000000 00000000 00000000 00000001	--原码
//	//11111111 11111111 11111111 11111110	--反码
//	//11111111 11111111 11111111 11111111	--补码
//	//因为是char类型，所以进行截取-->11111111
//	//因为要输出的是以十进制输出的有符号数，需要进行整型提升：
//	//因为signed char类型是有符号位的，看11111111第一位是1，认为是负数，
//	//所以在前面补1得
//	//11111111111111111111111111111111111	--得到补码
//	//再计算出原码就是-1;
//	unsigned char c = -1;
//	//10000000 00000000 00000000 00000001	--原码
//	//11111111 11111111 11111111 11111110	--反码
//	//11111111 11111111 11111111 11111111	--补码
//	//因为是char类型，所以进行截取-->11111111
//	//因为要输出的是以十进制输出的有符号数，需要进行整型提升：
//	//因为unsigned char类型是无符号位的，不管11111111第一位是1还是0，都在前面补0
//	//所以在前面补0得
//	//00000000 00000000 00000000 11111111	--得到补码
//	//这里是正数，原，反，补都相同，所以上面二进制转十进制得 255
//	printf("a = %d\nb = %d\nc = %d\n", a, b, c);
//
//
//	char d = -128;
//	//10000000 00000000 00000000 10000000	--原码
//	//11111111 11111111 11111111 01111111	--反码
//	//11111111 11111111 11111111 10000000	--补码
//	//因为d是char类型的，所以要进行数据截取，得 10000000
//	//又因为输出的格式为%u，-->以十进制无符号位输出
//	//所以要进行整型提升，又因为char类型是有符号位类型，所以
//	//看10000000第一位是1，认为是负数，所以在前面补1得
//	//11111111 11111111 11111111 10000000
//	//因为输出的是十进制无符号位输出，所以不认为，上面二进制第一位是负
//	//所以正数的 原，反，补相同，所以输出
//	//11111111 11111111 11111111 10000000	--> 4294967168
//	printf("d = %u\n", d);
//
//
//	char e = 128;
//	//其实这里输出的结果是和上面输出的一样的
//	//因为有符号char类型的数值范围是（-128~127）
//	//128超过了有符号位char类型范围，这里可以将128看成 127+1；
//	//而127的二进制数再加1，就成了-128；
//	//所以输出的结果和上一题是一样的
//	printf("e = %u\n", e);
//
//
//	int a1 = -20;
//	//10000000 00000000 00000000 00010100	-->原码
//	//11111111 11111111 11111111 11101011	-->反码
//	//11111111 11111111 11111111 11101100	-->补码
//	unsigned int a2 = -10;	
//	//这里一定要注意，虽然a2定义的是unsigned int,但是当-10存到内存，还是要先转换为补码，不是说你定义了unsigned int，就是以正数的形式存到内存中
//	//所以，无论整型的负数有没有定义unsigned int,都要先转换成补码形式，才能放到内存中
//	//这里的unsigned int 只是说，你-10存到内存的形式后，第一位是不当成符号位。
//	//但是前提是你要先将-10存到内存，那么要先存到内存，你也先把-10，转成补码形式，因为是负数
//	//10000000 00000000 00000000 00001010	-->原码
//	//11111111 11111111 11111111 11110101	-->反码
//	//11111111 11111111 11111111 11110110	-->补码
//
//	//11111111 11111111 11111111 11101100
//	//11111111 11111111 11111111 11110110
//   //111111111 11111111 11111111 11100010
//	//截去上面第一个1，得11111111 11111111 11111111 11100010  -->4294967266
//
//	printf("%d\n", a1 + a2);	//--> -30
//	printf("%u\n", a1 + a2);	//--> 4294967266
//
//
//	unsigned int b1 = -16;
//	unsigned int b2 = 10;
//	//C中，两个相加后，返回的是有符号数,因为前面规定是%d，一个有符号数，如果写成%u就是和下面一样
//	printf("%d\n", b1 + b2);	//--> -6
//	printf("%u\n", b1 + b2);	//--> 4294967290
//	//C++中，b1+b2会把两个数相加后返回的是无符号数
//	//cout << b1 + b2 << endl;
//	//C++中得特定规定一个有符号数接收，才会转成有符号数
//	////int m = b1 + b2;	-->  4294967290  
//	//cout << m << endl;	-->  -6
//
//
//	//unsigned int i;
//	////死循环
//	//for (i = 9; i >= 0; i--) {
//	//	//printf("%d\n", i);
//	//	printf("%u\n", i);
//	//	Sleep(1000);
//	//}
//
//	//unsigned char i = 0;
//	////死循环，因为255+1 = 0;
//	//for (i = 0; i <= 255; i++) {
//	//	printf("HelloWorld\n");
//	//}
//
//
//
//	char arr[1000];
//	int i;
//	for (i = 0; i < 1000; i++) {
//		arr[i] = -1 - i;
//		//-1,-2,-3,.....-1000;
//		//-1,-2,-3,....-128,127,126....1,0,-1,-2...
//		//所以当strlen识别到0时，结束，'\0' = 0;有255个元素
//	}
//	printf("%d", strlen(arr));
//
//
//
//
//	getchar();
//	return 0;
//}