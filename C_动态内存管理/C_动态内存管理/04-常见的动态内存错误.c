//#include <stdio.h>
//#include <stdlib.h>
//
//	//1、对NULL指针的解引用操作
//
//int main() {
//
//	//1、对NULL进行解引用操作
//	//int* p = (int*)malloc(40);
//	////万一malloc失败，p就被赋值为NULL，所以每次动态开辟内存的时候就要对p进行相关的判断
//	////*p = 0; //err
//
//	//int i = 0;
//	//for (i = 0; i < 10; i++) {
//	//	*(p + i) = i;	//err
//	//}
//
//	//free(p);
//	//p = NULL;
//
//
//
//	//2、对动态开辟内存的越界访问
//	//这里只开辟了5个整型元素的空间
//	//int* p = (int*)malloc(5 * sizeof(int));
//	//if (p == NULL) {
//	//	return 0;
//	//}
//	//else {
//	//	int i = 0;
//	//	//越界访问了
//	//	for (i = 0; i < 10; i++) {
//	//		*(p + i) = i;
//	//	}
//	//}
//
//	////释放内存
//	//free(p);
//	//p = NULL;
//
//
//
//	//3、对非动态开辟的内存使用free
//	//int a = 10;
//	//int* p = &a;
//	//*p = 20;
//
//	//free(p);
//	//p = NULL;
//
//
//
//	//4、使用free释放动态内存开辟内存的一部分
//	//free只能在开辟内存的起始位置开始释放，free里的参数的地址一定要是开辟内存的起始位置
//	//int* p = (int*)malloc(40);
//	//if (p == NULL) {
//	//	return 0;
//	//}
//	//int i = 0;
//	//for (i = 0; i < 10; i++) {
//	//	*p++ = i;
//	//}
//	////回收空间
//	//free(p);
//	//p = NULL;
//
//
//
//	//5、对同一块动态内存多次释放
//	//int* p = (int*)malloc(40);
//	//if (p == NULL) {
//	//	return 0;
//	//}
//	////使用
//	////释放
//	//free(p);
//	//p = NULL;	//所以这一步是非常有必要的，如果不写这句代码，就有可能对同一块动态内存多次释放的错误
//	////....
//	//free(p);	//多次释放了
//
//
//	
//	//6、对动态开辟内存空间忘记释放（内存泄露问题）
//	//int* p = (int*)malloc(40);
//	//下面代码会导致一直消耗内存，导致内存泄露
//	//while (1) {
//	//	malloc(1);
//	//	Sleep(1000);
//	//}
//
//
//
//
//	getchar();
//	return 0;
//}