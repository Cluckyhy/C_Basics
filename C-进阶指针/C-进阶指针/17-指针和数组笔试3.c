//#include <stdio.h>
//
////struct Test {
////	int Num;
////	char* pcName;
////	short sDate;
////	char cha[2];
////	short sBa[4];
////}*p;
//
//
//int main() {
//
//	//题目一
//	//int a[5] = { 1,2,3,4,5 };
//	//int* ptr = (int*)(&a + 1);
//	//printf("%d  %d\n", *(a + 1), *(ptr - 1));
//
//
//	//题目二
//	//考察指针+-整数
//	//取决于指针类型
//	//假设p的值为0x100000，如下表达式的值分别是多少？
//	//已知，结构体Test类型变量的大小是20个字节
//	
//	//什么类型的指针，+1后就是根据什么类型的指针加几个字节
//	//p = (struct Test*)0x100000;
//	//printf("%p\n", p + 0x1);					//0x100000+20 = 0x100014
//	//printf("%p\n", (unsigned long)p + 0x1);		//先整数加1，1048576+1 = 1048577；然后在转16进制后就是0x100000+1 = 0x100001
//	//printf("%p\n", (unsigned int*)p + 0x1);		//0x100000+4 = 0x100004
//
//
//	//题目三
//	//int a[4] = { 1,2,3,4 };
//	//int* ptr1 = (int*)(&a + 1);
//	//int* ptr2 = (int*)((int)a + 1);
//	////ptr1是一个指针，ptr[-1] == *(ptr+(-1)) == *(ptr-1)
//	////ptr1是一个int型指针，-1往前移4个字节 -- 所以当前指向的是4的地址，解引用后为4
//	////a是数组名，a就是首元素地址，将首元素地址看成整数加1的话，再转换成int*类型指针，地址相当于往后移了一个字节，因为相邻的两个地址相差一个字节
//	////a数组的内存为：01000000 02000000 03000000 04000000
//	////原先指向的是01前面，移一个字节后指向的是01后面的位置，再解引用的话，因为ptr2是int类型指针，解引用会往后读取4个字节
//	////就会读取出，00000002，本编译器是小端存储，所以读取出的16进制数是02000000，最前面的0可以省略
//	//printf("%X  %X\n", ptr1[-1], *ptr2);
//	////十六进制2000000  ==  十进制2*16^6 = 33554432
//	//printf("%d  %d", ptr1[-1], *ptr2);
//
//
//	//题目四
//	////注意这里数组里面写的是圆括号(),而逗号表达式，结果是最后一个结果，
//	////所以，其实a数组里面存放的数据是a[3][2] = {1,3,5}，其余元素补0；
//	//int a[3][2] = { (0,1),(2,3),(4,5) };
//	//int* p;
//	////a[0]是第一行的数组名，此时指的是1的地址
//	//p = a[0];
//	////p[0] == *(p+0)  解出来就是1
//	//printf("%d", p[0]);		//1
//
//
//	//题目五
//	//int a[5][5];
//	//int(*p)[4];
//	//p = a;		//此处会报一个警告，因为a是二维数组首元素地址，当是二维数组首元素地址时，我们通常把二维数组看成一维数组，
//	//			//所以a是二维数组首元素地址的话，就是第一行数组地址，a是一个存放5元素的数组地址，int(*)[5]，而p是存放4元素的数组指针，int (*)[4]
//	//			//类型不匹配所以报警告
//	////后一个输出值
//	////a[4][2]容易找，在第5行第3个元素位置处，p[4][2] == *(*(p+4)+2)，这里注意，p是int(*)[4]类型，+1跳过一个含4个元素的数组，
//	////+4就是跳过了4个含4个元素的数组，再解引用*(p+4)的话，就是拿到了第4个数组，+2就是指向了第4个数组的第3个元素
//	////解引用*(*(p+4)+2)就是拿到了第4个数组中的第3个元素，而下面又把它通过取地址符取出来了
//	////接下来进行指针相减，&p[4][2]的地址 - &a[4][2]得到的是中间元素个数，有4个，又因为p的地址更小，所以相减为-4
//	//
//	////前一个输出值
//	////因为已经算出&p[4][2] - &a[4][2] = -4;
//	////但是这里又是以%p地址形式打印的，-4存储在内存的话是以补码形式存储
//	////10000000 00000000 00000000 00000100	--原码
//	////11111111 11111111 11111111 11111011	--反码
//	////11111111 11111111 11111111 11111100	--补码
//	////4个一组，算出十六进制为fffffc
//	//printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
//
//
//	//题目六
//	//int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
//	//int* ptr1 = (int*)(&aa + 1);
//	//int* ptr2 = *(aa + 1);
//	////前一个输出
//	////&aa是二维数组的地址，+1相当于跳过了整个二维数组，指向在10的后面。还是一个数组地址，所以当要赋值给int* ptr1时，
//	////本身是需要一个数组指针来接收的，但是这里是int*类型的指针，所以需要强制类型转换成(int*)
//	////当ptr1-1，因为ptr1是int*类型，所以-1是往前移动了4个字节。指向了二维数组的10，再进行解引用，就数输出了10
//	////后一个输出
//	////aa不是sizeof(数组名)和&数组名，这两种情况，所以这里的aa是首元素地址，当是二维数组的首元素地址时，我们通常把二维数组看成是一维数组
//	////所以此时的aa是二维数组的第一行地址。+1后就是第二行的地址，解引用后其实就是二维数组第二行的首元素地址，*(aa+1)  == aa[1]，
//	////再将aa[1]的地赋给int*类型的ptr2，ptr2-1就是往前移了4个字节，使指指向了5的位置，解引用后就是输出 5;
//	//printf("%d  %d\n", *(ptr1 - 1), *(ptr2-1));		//10和5
//
//	
//	//题目七
//	////a是一个字符指针数组，数组里面存的是char类型的指针，这里分别存放的是'w'的地址，'a'的地址，'a'的地址
//	////a是数组名，这里即表示的是首元素地址，又因为首元素是一个指针(地址)，所以要用二级指针才能存放一个地址的地址
//	////char**pa二级指针，里面存放的就是a首元素地址，char* *pa，所以pa的类型是char*型的，pa++就相当于跳过一个char*类型的数据
//	////所以就指向了数组的第二个元素地址，*pa解引用pa，就是获得了第二个元素的地址，printf("%s\n",地址)，就是从当前地址，开始往后读取字符
//	////直到读取到'\0'，所以"at"里面是有'\0'的，所以最终答案就是at
//	//char* a[] = { "work","at","alibaba" };
//	//char** pa = a;
//	//pa++;
//	//printf("%s\n", *pa);
//
//
//	//题目八(最复杂的，建议画图理解)
//	char* c[] = { "ENTER","NEW","POINT","FIRST" };
//	char** cp[] = { c + 3,c + 2,c + 1,c };
//	char*** cpp = cp;
//	//这题的注意点是，++cp后，是改变了它的值，进行第二次运算时，已经不是开始值了，不像cp+1，这种是cp的值是不改变的
//	//++cpp = 指向的是cp[]的第二个元素地址，*++cpp后就是拿到第二个元素的值，也就是c+2，再解引用后拿到的是'P'的地址，
//	//所以开始往后读取数据，直到'\0'，所以这里输出是POINT
//	printf("%s\n", **++cpp);			//POINT
//	//因为前面++cpp已经改变了cpp的值，所以这里再次++cpp = 指向的是cp[]第三个元素地址，解引用后拿到的是c+1，再--指向的是cp[]第一个元素
//	//再解引用后就是'E'的地址，+3就是跳过ENT三个字符，然后开始往后读取数据，直到'\0'，所以这里输出ER
//	printf("%s\n", *--*++cpp + 3);		//ER
//	//注意此时，cpp还是指向的是cp[]第三个元素的地址，cpp[-2] == *(cpp-2)，-2后指向的是cp[]第一个元素地址，解引用后拿到的是c
//	//再解引用后，拿到的是'F'的地址，+3说明跳过了FIR三个字符，所以这里输出的是ST
//	printf("%s\n", *cpp[-2] + 3);		//ST
//	//此时cpp还是指向的是cp[]第三个元素地址，cpp[-1] == *(cpp-1)，-1后指向的是cp[]第二个元素地址c+1，cpp[-1][-1] == *(*(cpp-1)-1)
//	//c+1再-1后拿到的是cp[]的第二个元素c+2，解引用后拿到的是'N'的地址，再+1后表示跳过N字符，开始往后读取字符，直到'\0'
//	//所以这里输出的是EW
//	printf("%s\n", cpp[-1][-1] + 1);	//EW
//
//
//	getchar();
//	return 0;
//}