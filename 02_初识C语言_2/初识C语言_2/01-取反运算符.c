//#include <stdio.h>
//
//
////只要是整数，内存中存储的都是二进制的补码形式
////正数 -->  原码=反码=补码
////负数：
////原码        -->        反码        -->          补码
////直接按照正负			原码的符号位不变			 反码+1
////写出的二进制序列		其他位按位取反
//
//
//
//
//int main() {
//
//	//int arr[10] = { 88 };
//	//char ch[10] = "Hello Wor";
//	//for (size_t i = 0; i < 10; i++)
//	//{
//	//	printf("%c\n", ch[i]);
//	//}
//	//printf("%s\n", "\101");
//	char ch[5] = { 'd','a','f' };
//	printf("%s\n", ch);
//	printf("%d\n", sizeof(ch));
//
//	int a = 3;
//	//0000000000 0000000000 0000000000 11
//	int b = ~a;
//	//1111111111 1111111111 1111111111 00
//	//原码，反码，补码  （补码 = 除符号位原码取反变成反码 + 1）
//	//负数在内存中存储的时候，存储的是二进制的补码
//	//1111111111 1111111111 1111111110 11
//	//1000000000 0000000000 0000000001 00  = -4
//
//	//其实可以直接按8位来算，32位太长了
//	//3 -- 0000 0011
//	//取反后
//	//  -- 1111 1100
//	//注意这里取反后是负数，然后在内存中是以补码形式
//    //  -- 1000 0011 + 1 = 原码： 1000 0100
//	printf("%d\n", b);   // -4  使用时，打印的是这个数的原码
//
//	int a1 = -2;
//	//1000000000 0000000000 0000000000 10
//	//上面是负数，记住，负数在内存中，是二进制的补码形式，所以要转成下面形式再进行取反
//	int b1 = ~a1;
//	//补码形式
//	//1111111111 1111111111 1111111111 10
//	//取反后
//	//0000000000 0000000000 0000000000 01
//	//上面就是正数，所以直接打印出1
//	//b1 = 1
//
//	//其实可以直接按8位来算，32位太长了
//	//-2 -- 1000 0010
//	//负数要存在内存必须要是补码形式，所以转为补码为：1111 1101 + 1 = 1111 1110
//	//取反后
//	//  -- 0000 0001   b1 = 1
//
//	printf("%d\n", b1);
//
//
//	int a3 = 7;
//	int b3 = ~a3;
//	printf("%d\n", b3);
//	/*
//	结果是-8。这是 为什么呢？
//	第一步：整数型变量a的二进制表示原码为00000111。内存中的补码为00000111
//	第二步：对内存中的内容进行按位取反，得到的内存中的补码为： 11111000（左数第一位为符号位，正数取反后为负数），补码为负数。
//	第三步：这是重点，当内存中的补码转为原码后：正数的补码转为原码不变，负数的补码转为原码是对补码（除符号位）逐位取反后，并在最低位＋1。
//	第四步：运算
//	10000111
//	＋1就等于10001000
//	结果为：-8
//	*/
//
//	int a4 = -7;
//	int b4 = ~a4;
//	printf("%d\n", b4);
//
//	/*
//	结果为：6
//	第一步：整数型变量a的二进制表示原码为10000111。内存中的补码为11111001
//	第二步：对内存中的内容进行按位取反，得到的内存中的补码为：00000110（左数第一位为符号位，负数取反后为正数），补码为正数。
//	第三步：这是重点，当内存中的补码转为原码后：正数的补码转为原码不变，负数的补码转为原码是对补码（除符号位）逐位取反后，并在最低位＋1。
//	第四步：运算
//	00000110
//	结果为：6
//	*/
//
//	
//	
//	getchar();
//	return 0;
//}